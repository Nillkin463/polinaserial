#!/usr/bin/env python3

import sys
from pathlib import Path

RELEVANT_EXTENSIONS = [".c", ".cpp", ".s", ".S"]
RELEVANT_PATTERNS = ["print", "panic", "assert", "log"]

def find_relevant_files(root: str) -> set[str]:
    result = set()

    for path, _, files in Path(root).walk():
        for file in files:
            full_path = path / file

            if full_path.suffix not in RELEVANT_EXTENSIONS:
                continue

            if path.name == "tools":
                continue

            with open(full_path, "r") as f:
                try:
                    buf = f.read()
                except UnicodeDecodeError:
                    continue

            for pattern in RELEVANT_PATTERNS:
                if pattern in buf.lower():
                    result.add(str(full_path.relative_to(root)))
                    break

    return result

def encode(hmacs: list[int], hmacs_to_file: dict, filename: str) -> str:
    result = str()

    result += "/* AUTOGENERATED */\n"

    header_upper = filename.upper() + "_H"

    result += \
        "#ifndef %s\n#define %s\n" % (header_upper, header_upper)
    
    result += "\n"

    result += "#include \"iboot.h\"\n"

    result += "\n"

    result += "static const iboot_hmac_config_t iboot_hmac_config[] = {\n"

    for hmac in hmacs:
        result += "    {0x%016x, \"%s\"},\n" % (hmac, hmacs_to_file[hmac])

    result += "};\n"

    result += "\n"

    result += "static const size_t iboot_hmac_config_count = sizeof(iboot_hmac_config) / sizeof(iboot_hmac_config_t);\n"

    result += "\n"

    result += "#endif\n"

    return result

def main():
    if len(sys.argv) != 4:
        print("usage: %s <input.txt> <output.h> <iboot root>" % sys.argv[0])
        exit(-1)

    _, input_file, output_file, iboot_root = sys.argv

    try:
        with open(input_file, "r") as f:
            lines = f.readlines()
    except IOError:
        print("failed to read input")
        exit(-1)

    relevant_files = find_relevant_files(iboot_root)
    hmacs_to_file = dict()

    for line in lines:
        if not line:
            continue

        splitted = line.split(":")

        if len(splitted) != 2:
            print("bad line: %s" % line)
            exit(-1)

        file, hmac = splitted

        if file not in relevant_files:
            continue

        try:
            hmac_decoded = int(hmac, 16)
        except ValueError:
            print("bad hmac: %s" % hmac)
            exit(-1)

        hmacs_to_file[hmac_decoded] = file

    sorted_hmacs = sorted(hmacs_to_file.keys())

    result = encode(sorted_hmacs, hmacs_to_file, Path(output_file).stem)

    try:
        with open(output_file, "w") as f:
            f.write(result)
    except IOError:
        print("failed to write output")
        exit(-1)

    print("%d entries" % len(sorted_hmacs))

if __name__ == "__main__":
    main()
